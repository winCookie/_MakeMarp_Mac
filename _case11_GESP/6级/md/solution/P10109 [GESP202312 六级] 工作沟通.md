### P10109 [GESP202312 六级] 工作沟通

#### ▍题意  

某公司有 $N$ 名员工，编号从 $0$ 到 $N-1$，其中 $0$ 号员工是老板。除老板外，每个员工都有一个直接领导，形成树形结构。员工 $x$ 可以管理员工 $y$ 当且仅当 $x$ 是 $y$ 的祖先（包括 $y$ 自己）。现在有 $Q$ 场合作，每场合作有 $m$ 名员工参与，需要找出一名能够管理所有参与员工的主持人（即所有参与员工的公共祖先），如果有多个满足条件的主持人，选择编号最大的那个。  
数据范围：$3 \leq N \leq 300$，$Q \leq 100$，$2 \leq m \leq N$。

---



#### ▍分析  

本题的核心是求多个节点的公共祖先。公司结构是一棵以 $0$ 号员工为根的树，每个员工的管理者就是其祖先节点（包括自己）。

**关键观察**：

- 员工 $x$ 能够管理员工 $y$ 当且仅当 $x$ 是 $y$ 的祖先
- 因此，主持人必须是所有参与员工的公共祖先
- 需要找出所有公共祖先中编号最大的

**算法思路**：

1. 预处理每个员工的父节点信息
2. 对于每次查询：
   - 先找出第一个员工的所有祖先（包括自己）
   - 依次与其他员工求祖先集合的交集
   - 在最终的交集中选择编号最大的员工作为主持人

---

**正确性证明**：

- 初始时，第一个员工的所有祖先都是候选集合
- 每次与其他员工求交集，保留同时是两者祖先的节点
- 最终集合中的节点都是所有参与员工的公共祖先
- 选择编号最大的满足题目要求

**时间复杂度**：

- 每次查询需要遍历最多 $m$ 个员工，每个员工最多有 $N$ 个祖先
- 总时间复杂度为 $O(Q \cdot m \cdot N)$，在给定数据范围内完全可行

---

#### ▍参考代码  

```cpp
const int N = 1005;
int n, q, fa[N], query[N], m;

int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    cin >> n;
    fa[0] = -1; // 老板没有父节点
    // 读入每个员工的直接领导
    for (int i = 1; i < n; i++)
        cin >> fa[i];
    
    cin >> q;
    while (q--) {
        cin >> m;
        // 读入本次合作的所有员工
        for (int i = 0; i < m; i++)
            cin >> query[i];
        
        bool vis[N] = {0}; // 标记公共祖先集合
        
        // 初始化：第一个员工的所有祖先都是候选
        int now = query[0];
        while (now != -1) {
            vis[now] = 1;
            now = fa[now];
        }
        
        // 与其他员工求交集
        for (int i = 1; i < m; i++) {
            bool tmp[N] = {0}; // 当前员工的祖先集合
            now = query[i];
            while (now != -1) {
                tmp[now] = 1;
                now = fa[now];
            }
            // 取交集：只有同时在两个集合中的节点才保留
            for (int j = 0; j < n; j++)
                vis[j] = vis[j] && tmp[j];
        }
        
        // 找编号最大的公共祖先
        int ans = -1;
        for (int j = 0; j < n; j++)
            if (vis[j] && j > ans)
                ans = j;
        
        cout << ans << endl;
    }
    return 0;
}
```