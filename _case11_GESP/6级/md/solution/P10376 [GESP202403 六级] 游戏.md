### P10376 [GESP202403 六级] 游戏

#### ▍题意  

游戏从正整数 $n$ 开始，每轮可以选择将 $n$ 减去 $a$ 或减去 $b$，游戏在 $n \leq c$ 时结束。求不同的游戏操作序列数量，即使 $a = b$，减去 $a$ 和减去 $b$ 也被视为不同操作。答案对 $10^9 + 7$ 取模。  
数据范围：$1 \leq a,b,c \leq n \leq 2 \times 10^5$。

---

#### ▍分析  

这是一个典型的动态规划问题。我们需要计算从 $n$ 出发，通过不断减去 $a$ 或 $b$ 到达 $\leq c$ 状态的所有不同路径数量。

**状态定义**：  
设 $dp[i]$ 表示从 $n$ 开始到达数字 $i$ 的不同操作序列数量。

**状态转移**：  
对于当前数字 $i$，我们可以选择减去 $a$ 或减去 $b$：

- 如果 $i - a \leq c$，说明这一步会直接结束游戏，所有路径都汇聚到状态 $c$
- 如果 $i - a > c$，则转移到状态 $i - a$
- 同理处理减去 $b$ 的情况

状态转移方程为：
$$
dp[i-a] = dp[i-a] + dp[i] \quad (\text{当 } i-a > c)
$$
$$
dp[c] = dp[c] + dp[i] \quad (\text{当 } i-a \leq c)
$$

---

**流程**：

1. 初始化 $dp[n] = 1$（起点）
2. 从 $n$ 到 $c+1$ 倒序遍历
3. 对于每个 $i$，分别处理减去 $a$ 和减去 $b$ 的情况
4. 最终 $dp[c]$ 即为所有结束状态的方案数之和

**时间复杂度**：$O(n)$，每个状态最多被访问一次。

---

▍参考代码
```cpp
const int N = 2e5 + 10;
const int mod = 1e9 + 7;
int dp[N];
int n, a, b, c;

int main() {
    cin >> n >> a >> b >> c;
    
    // 初始化：从n开始的方案数为1
    dp[n] = 1;
    
    // 从n到c+1倒序遍历
    for (int i = n; i > c; i--) {
        // 处理减去a的情况
        if (i - a <= c)
            dp[c] = (dp[c] + dp[i]) % mod;  // 直接结束游戏
        else
            dp[i - a] = (dp[i - a] + dp[i]) % mod;  // 转移到新状态
        
        // 处理减去b的情况  
        if (i - b <= c)
            dp[c] = (dp[c] + dp[i]) % mod;  // 直接结束游戏
        else
            dp[i - b] = (dp[i - b] + dp[i]) % mod;  // 转移到新状态
    }
    
    cout << dp[c] << endl;
    return 0;
}
```

---

**记忆化搜索版本**：

```cpp
const int N = 2e5 + 10, mod = 1e9 + 7;
int mem[N], n, a, b, c;

// 记忆化搜索：计算从x开始的方案数
int dfs(int x) {
    if (x <= c)  // 终止条件
        return 1;
    if (mem[x] != -1)  // 记忆化
        return mem[x];
    // 递归计算两种选择的方案数之和
    return mem[x] = (dfs(x - a) + dfs(x - b)) % mod;
}

int main() {
    memset(mem, -1, sizeof mem);  // 初始化记忆化数组
    cin >> n >> a >> b >> c;
    cout << dfs(n) << endl;
    return 0;
}
```