### P11376 [GESP202412 六级] 运送物资
▍题意
  有 $n$ 个运输站点位于 A 市（坐标 $0$）和 B 市（坐标 $x$）之间，第 $i$ 个站点的坐标为 $p_i$（$0 < p_i < x$），最多容纳 $c_i$ 辆货车。有 $m$ 辆货车，第 $j$ 辆货车每天需要向 A 市运送 $a_j$ 次物资，向 B 市运送 $b_j$ 次物资。货车从分配站点出发，前往 A 市或 B 市后返回，每次去 A 市行驶路程为 $2p_i$，去 B 市行驶路程为 $2(x - p_i)$。求在最优分配站点的情况下，所有货车每天的最短总行驶路程。

  数据范围：$1 \leq n, m \leq 10^5$，$2 \leq x \leq 10^8$，$1 \leq c_i \leq 10^5$，$0 \leq a_j, b_j \leq 10^5$，保证 $\sum c_i \geq m$。

---

▍分析
  1. **问题转化**：对于货车 $j$ 分配到站点 $i$，其每日行驶路程为 $2a_j p_i + 2b_j (x - p_i) = 2p_i (a_j - b_j) + 2b_j x$。其中 $2b_j x$ 为常数，因此最小化总路程等价于最小化 $2p_i (a_j - b_j)$ 的总和。

  2. **关键观察**：
     - 当 $a_j \geq b_j$ 时，$a_j - b_j \geq 0$，因此 $p_i$ 越小，$2p_i (a_j - b_j)$ 越小。
     - 当 $a_j < b_j$ 时，$a_j - b_j < 0$，因此 $p_i$ 越大，$2p_i (a_j - b_j)$ 越小（负值绝对值越大）。
     - 因此，应将 $a_j \geq b_j$ 的货车分配到 $p_i$ 较小的站点，将 $a_j < b_j$ 的货车分配到 $p_i$ 较大的站点。

---

  3. **贪心策略**：
     - 将货车分为两组：$f$ 组（$a_j \geq b_j$）和 $g$ 组（$a_j < b_j$）。
     - 对站点按 $p_i$ 从小到大排序。
     - 对 $f$ 组按 $(a_j - b_j)$ 降序排序，优先将 $(a_j - b_j)$ 大的货车分配到 $p_i$ 小的站点，以最大化节省。
     - 对 $g$ 组按 $(b_j - a_j)$ 降序排序，优先将 $(b_j - a_j)$ 大的货车分配到 $p_i$ 大的站点，以最大化节省。
     - 在站点容量限制下，按顺序分配站点。

---

  4. **正确性证明**：
     - 对于 $f$ 组，设两辆货车 $j$ 和 $k$ 满足 $(a_j - b_j) > (a_k - b_k)$，若分配站点 $p_1 < p_2$。
     
         则分配方案 $j \to p_1$、$k \to p_2$ 的总代价为 $2p_1(a_j - b_j) + 2p_2(a_k - b_k)$。
     
         若交换则代价为 $2p_2(a_j - b_j) + 2p_1(a_k - b_k)$。
     
         由于 $(a_j - b_j) > (a_k - b_k)$ 且 $p_1 < p_2$，
     
         有 $p_1(a_j - b_j) + p_2(a_k - b_k) < p_2(a_j - b_j) + p_1(a_k - b_k)$，因此原方案更优。
     
     - 同理可证 $g$ 组分配策略的最优性。
     
     - 站点容量限制通过顺序分配保证，且数据保证 $\sum c_i \geq m$，故所有货车均能被分配。

  时间复杂度：排序 $O(n \log n + m \log m)$，分配 $O(m)$，总时间复杂度 $O(n \log n + m \log m)$。

---

▍参考代码
```cpp
struct Station {
    int p, c; // 站点位置和容量
} d[N];

struct Truck {
    int a, b; // 货车向A、B运送次数
} f[N], g[N];

int fcnt, gcnt; // f组和g组的货车数量
int ans;        // 总行驶路程

// 按站点位置升序排序
bool cmpStation(Station a, Station b) {return a.p < b.p;}

// 按(a-b)降序排序，用于f组
bool cmpF(Truck x, Truck y) {return x.a - x.b > y.a - y.b;}

// 按(b-a)降序排序，用于g组
bool cmpG(Truck x, Truck y) {return x.b - x.a > y.b - y.a;}
```

---

```cpp
signed main() {
    int n, m, x;
    cin >> n >> m >> x;
    
    // 读入站点数据
    for (int i = 1; i <= n; i++) 
        cin >> d[i].p >> d[i].c;
    
    // 读入货车数据并分组
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        if (a >= b) 
            f[++fcnt] = {a, b};
        else 
            g[++gcnt] = {a, b};
```

---

```cpp
    // 排序
    sort(d + 1, d + n + 1, cmpStation),sort(f + 1, f + fcnt + 1, cmpF),sort(g + 1, g + gcnt + 1, cmpG);
    
    // 分配f组货车到小位置站点
    int idx = 1; // 指向当前最小站点
    for (int i = 1; i <= fcnt; i++) {
        while (d[idx].c == 0) idx++; // 跳过已满站点
        ans += 2 * f[i].a * d[idx].p + 2 * f[i].b * (x - d[idx].p);
        d[idx].c--;
    }
    
    // 分配g组货车到大位置站点
    idx = n; // 指向当前最大站点
    for (int i = 1; i <= gcnt; i++) {
        while (d[idx].c == 0) idx--; // 跳过已满站点
        ans += 2 * g[i].a * d[idx].p + 2 * g[i].b * (x - d[idx].p);
        d[idx].c--;
    }
    cout << ans << endl;
    return 0;
}
```