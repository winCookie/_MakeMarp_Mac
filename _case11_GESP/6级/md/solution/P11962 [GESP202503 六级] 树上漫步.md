### P11962 [GESP202503 六级] 树上漫步
#### ▍题意

  给定一棵 $n$ 个节点的树，从每个节点出发，经过偶数步（步数可以为 $0$）能到达的节点数量。每一步可以移动到相邻节点，且允许重复访问节点。

  数据范围：$1 \leq n \leq 2 \times 10^5$。

#### ▍分析

  1. **问题转化**：树是一个二分图，可以按节点深度的奇偶性进行染色。从任意节点出发，经过偶数步只能到达与起点深度奇偶性相同的节点，因为每一步都会改变深度的奇偶性。

  2. **关键观察**：
     - 设节点深度的奇偶性为颜色：深度为偶数的节点颜色为 $0$，深度为奇数的节点颜色为 $1$。
     - 从颜色为 $c$ 的节点出发，经过偶数步只能到达颜色为 $c$ 的节点。
     - 因此，对于每个节点，能到达的节点数量等于与其颜色相同的节点总数。

---

  3. **算法步骤**：
     - 从根节点（节点 $1$）开始进行 DFS 或 BFS，计算每个节点的深度（从根节点开始的步数）。
     - 统计深度为偶数的节点数量 $cnt_0$ 和深度为奇数的节点数量 $cnt_1$。
     - 对于每个节点 $i$，如果其深度为偶数，则答案为 $cnt_0$；否则为 $cnt_1$。

  4. **正确性证明**：
     - 由于树是无环连通图，且边连接不同深度的节点，因此深度奇偶性定义了合法的二分图染色。
     - 从任意节点出发，每一步移动都会改变深度奇偶性，因此偶数步后深度奇偶性与起点相同。
     - 由于允许重复访问节点，且树是连通的，从起点可以到达所有同色节点（通过来回移动调整步数）。

  时间复杂度：$O(n)$，遍历树一次。

---

#### ▍参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 200010;
vector<int> graph[N]; // 邻接表存储树
int color[N];         // color[i]表示节点i的颜色：0表示偶数深度，1表示奇数深度
int cnt[2];           // cnt[0]记录偶数深度节点数，cnt[1]记录奇数深度节点数

void dfs(int node, int parent, int depth) {
    // 根据当前深度设置颜色并计数
    color[node] = depth % 2;
    cnt[color[node]]++;
    
    // 遍历相邻节点
    for (int neighbor : graph[node]) {
        if (neighbor != parent) { // 避免回到父节点
            dfs(neighbor, node, depth + 1);
        }
    }
}

int main() {
    int n;
    cin >> n;
    
    // 读入边，构建树
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // 从节点1开始DFS，初始深度为0（偶数）
    dfs(1, 0, 0);
    
    // 输出每个节点的答案
    for (int i = 1; i <= n; i++) {
        cout << cnt[color[i]] << " ";
    }
    
    return 0;
}
```