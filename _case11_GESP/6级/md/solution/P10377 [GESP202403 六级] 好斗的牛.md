### P10377 [GESP202403 六级] 好斗的牛
▍题意
  有 $10^9$ 个牛棚排成一排，需要安置 $n$ 头牛。第 $i$ 头牛的攻击范围是 $(a_i, b_i)$，意味着如果它左边 $a_i$ 个牛棚或右边 $b_i$ 个牛棚内有其他牛，它就会挑事。要求选择一段连续的牛棚，使得能够安置所有牛且没有牛会挑事，求这段连续牛棚的最短长度。

  数据范围：$1 \leq n \leq 9$，$1 \leq a_i, b_i \leq 10^3$。

#### ▍分析

  1. **问题转化**：由于 $n$ 很小，可以考虑枚举所有牛的排列顺序。对于每种排列，计算安置这些牛所需的最小连续牛棚长度。关键在于确定牛之间的最小间隔。
  
  2. **关键观察**：当按顺序放置牛时，相邻两头牛之间需要满足攻击范围的要求。具体地，如果前一头牛（编号为 $last$）放在位置 $x$，当前牛（编号为 $i$）放在位置 $y$（$y > x$），则为了确保两头牛都不挑事，间隔必须至少为 $\max(b_{last}, a_i)$。这是因为：
     - 前一头牛 $last$ 的右攻击范围为 $b_{last}$，所以 $y - x - 1 \geq b_{last}$（即中间空牛棚数至少为 $b_{last}$）。
     - 当前牛 $i$ 的左攻击范围为 $a_i$，所以 $y - x - 1 \geq a_i$。
     因此，最小间隔为 $\max(b_{last}, a_i)$，从而 $y = x + \max(b_{last}, a_i) + 1$。
  
  3. **算法步骤**：
     - 使用 DFS 枚举所有 $n!$ 种排列顺序。
     - 对于每种排列，从第一头牛开始放置（位置为 $1$），然后依次计算后续牛的位置：如果前一头牛在位置 $x$，则下一头牛在位置 $x + \max(b_{last}, a_i) + 1$。
     - 最后一头牛的位置即为所需连续牛棚的长度（因为牛棚从位置 $1$ 开始连续）。
     - 在所有排列中取最小长度作为答案。
  
  4. **正确性证明**：通过枚举所有排列，确保考虑到所有可能的安置顺序。递推公式保证了相邻牛之间的间隔满足攻击范围要求，且由于攻击范围的对称性，非相邻牛之间也会自动满足条件（因为间隔更大）。

  时间复杂度：$O(n! \cdot n)$，在 $n \leq 9$ 时可行。

#### ▍参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 15;
const long long INF = 0x3f3f3f3f3f3f3f3f;
int a[N], b[N], n;
long long ans;
bool vis[N];

// DFS枚举所有排列：p表示当前已放置牛的数量，last表示上一头牛的编号，cost表示当前最后一头牛的位置
void dfs(int p, int last, long long cost) {
    if (p > n) { // 所有牛都已放置
        ans = min(ans, cost); // 更新最小长度
        return;
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) { // 如果牛i未被放置
            vis[i] = true;
            if (p == 1) {
                // 放置第一头牛，位置为1
                dfs(p + 1, i, 1);
            } else {
                // 放置后续牛：新位置 = 原位置 + 最大攻击范围 + 1
                dfs(p + 1, i, cost + max(b[last], a[i]) + 1);
            }
            vis[i] = false; // 回溯
        }
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    ans = INF; // 初始化答案为极大值
    dfs(1, 0, 1); // 开始DFS，初始状态：放置第1头牛，上一头牛编号为0（无效），当前位置为1
    cout << ans << endl;
    return 0;
}
```