### P14075 [GESP202509 六级] 划分字符串
#### ▍题意

  给定一个长度为 $n$ 的字符串 $s$，需要将其划分为若干个子串，使得每个子串中每个字母至多出现一次。划分后长度为 $i$ 的子串价值为 $a_i$，求所有划分方案中子串价值之和的最大值。

  数据范围：$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

---

#### ▍分析

  1. **问题转化**：这是一个动态规划问题，需要找到最优的字符串划分方式，使得每个子串中无重复字符，且总价值最大。

  2. **关键观察**：
     - 定义状态 $f[i]$ 表示考虑前 $i+1$ 个字符（下标 $0$ 到 $i$）时的最大价值
     - 对于每个位置 $i$，有两种选择：
       - 将第 $i$ 个字符单独作为一个子串：$f[i] = f[i-1] + a_1$
       - 将第 $i$ 个字符与前面的若干字符组成一个子串：$f[i] = \max(f[j-1] + a_{i-j+1})$，其中子串 $s[j..i]$ 无重复字符

---

  3. **算法优化**：
     - 由于字符集只有 $26$ 个小写字母，从位置 $i$ 往前枚举时，最多只需要检查 $26$ 个字符就会遇到重复
     - 使用集合记录当前子串中的字符，遇到重复立即停止枚举
     - 这样内层循环的时间复杂度为 $O(26)$，整体为 $O(26n)$

  4. **算法正确性**：
     - 最优子结构：到达位置 $i$ 的最优解必然由某个位置 $j$ 的最优解加上子串 $s[j..i]$ 的价值构成
     - 通过枚举所有可能的 $j$ 并确保子串无重复字符，保证找到全局最优解
     - 使用集合快速判断字符重复，提高算法效率

  时间复杂度：$O(26n)$，在 $n \leq 10^5$ 时可行。

----

#### ▍参考代码

```cpp
// f[i]：以 i 为结尾的子串最大分值。
// 转移：选和不选，不选 f[i] = f[i-1] + cost[ 1 ]; 独立一段
// 选择与前面一段拼接为子串，其中 j 为子串开头的位置，i 末尾
// f[i] = max(f[j-1] + cost[ i-j+1 ], f[i])
// 初始：f[0] = a[1], 下标从 0 开始，长度为 1 的分值
// 答案：f[n-1]
const int N = 1e5 + 10;
int cost[N], f[N], n;
string p;
signed main() {
    cin >> n;
    cin >> p;
    for (int i = 1; i <= n; i++)
        cin >> cost[i];
    f[0] = cost[1];
    for (int i = 1; i < n; i++) {
        f[i] = f[i - 1] + cost[1]; // 独立一段
        set<int> s;
        s.insert(p[i]);
        // 枚举子串的起点
        for (int j = i - 1; j >= 0; j--) {
            if (s.count(p[j])) // 重复字符，直接断
                break;
            // 特判子串从下标 0 的情况，也就是子串可以开头到现在位置
            f[i] = max(f[i], (j == 0 ? 0 : f[j - 1]) + cost[i - j + 1]);
            s.insert(p[j]);
        }
    }
    cout << f[n - 1] << endl;
    return 0;
}
```