### B3874 [GESP202309 六级] 小杨的握手问题
#### ▍题意

  有 $N$ 名同学，学号从 $0$ 到 $N-1$，按照给定顺序依次进入教室。每位同学进入教室时，需要和已经在教室内且学号小于自己的同学握手。求总共会进行多少次握手。

  数据范围：$2 \leq N \leq 3 \times 10^5$。

---

#### ▍分析

  1. **问题转化**：对于进入顺序序列中的每个位置 $i$，我们需要统计在它之前进入教室且学号小于当前学号的同学数量，然后将所有统计结果求和。

  2. **关键观察**：这实际上是一个**逆序对计数**问题的变形。在归并排序过程中，当合并两个有序子序列时，可以高效地统计逆序对数量。

---

  3. **算法思路**：
     - 使用归并排序算法对进入顺序序列进行排序
     - 在合并两个有序子序列时，如果左半部分的当前元素大于右半部分的当前元素，说明存在逆序对
     - 统计所有逆序对的数量，即为总握手次数

  4. **正确性证明**：
     - 对于任意两个同学 $(i, j)$，如果 $i$ 在 $j$ 之前进入教室且学号 $a_i > a_j$，则 $j$ 进入时不会与 $i$ 握手（因为学号 $a_j < a_i$）
     - 因此，握手次数 = 所有可能的对数 - 逆序对数量
         - 这里可以优化成，从大到小排序，统计逆序对数量即可。
     - 所有可能的对数为 $\frac{N(N-1)}{2}$，逆序对数量可以在归并排序中统计

  时间复杂度：$O(N \log N)$，在 $N \leq 3 \times 10^5$ 时可行。

---

#### ▍参考代码

```cpp
#define int long long
const int N = 3e5 + 10;
int n, a[N], b[N], ans;
void msort(int l, int r) {
    if (l >= r)
        return;
    int mid = (l + r) / 2;
    msort(l, mid), msort(mid + 1, r);
    int i = l, j = mid, st = mid + 1, ed = r, len = l;
    while (i <= j && st <= ed) {
        if (a[i] >= a[st])
            b[len++] = a[i++];
        else {
            b[len++] = a[st++];
            // 合并序列过程，存在逆序对，贡献即为 [i,mid]
            ans += j - i + 1;
        }
    }
    while (i <= j)
        b[len++] = a[i++];
    while (st <= ed)
        b[len++] = a[st++];
    for (int i = l; i <= r; i++)
        a[i] = b[i];
}
```

