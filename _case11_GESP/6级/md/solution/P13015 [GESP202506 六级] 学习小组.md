### P13015 [GESP202506 六级] 学习小组
#### ▍题意

  将 $n$ 名同学划分为若干个学习小组，每个小组有 $k$ 名同学时，其讨论积极度为 $a_k$。求所有划分方案中，讨论积极度之和的最大值。

  数据范围：$1 \leq n \leq 1000$，$0 \leq a_i \leq 10^4$。

---

#### ▍分析

  1. **问题转化**：这是一个典型的完全背包问题，需要找到将 $n$ 名同学划分为若干小组的最优方案，使得总积极度最大。

  2. **关键观察**：
     - 每个小组的人数 $k$ 可以看作是背包问题中的"物品重量"
     - 对应的积极度 $a_k$ 可以看作是"物品价值"
     - 总人数 $n$ 可以看作是背包的"容量"
     - 需要找到在容量为 $n$ 的背包中能装入的最大价值

  3. **动态规划思路**：
     - 定义状态 $dp[i]$ 表示将 $i$ 名同学划分成学习小组能获得的最大积极度之和
     - 状态转移：对于每个可能的小组人数 $k$（从 $1$ 到 $n$），更新 $dp[i] = \max(dp[i], dp[i-k] + a_k)$
     - 初始化：$dp[0] = 0$，其他为 $0$（因为积极度非负）

---

  4. **算法正确性**：
     - 最优子结构：将 $i$ 名同学划分的最优解必然由将 $i-k$ 名同学划分的最优解加上一个 $k$ 人小组的积极度构成
     - 通过枚举所有可能的小组人数，并使用完全背包的更新顺序，确保每个小组人数可以使用多次
     - 由于积极度非负，初始化时设为 $0$ 是安全的

  时间复杂度：$O(n^2)$，在 $n \leq 1000$ 时可行。

---

#### ▍参考代码

```cpp
const int N = 1005;
int dp[N], cost[N], n;
// dp[i] : 所有的在 n 种分类方案情况下，总人数为 i 名同学情况下的最大分值。
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> cost[i];
    dp[0] = 0;
    for (int i = 1; i <= n; i++)     // 物品，分组人数
        for (int j = i; j <= n; j++) // 体积，总人数
            dp[j] = max(dp[j], dp[j - i] + cost[i]);
    cout << dp[n] << endl;
    return 0;
}
```