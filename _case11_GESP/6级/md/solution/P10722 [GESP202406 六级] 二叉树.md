### P10722 [GESP202406 六级] 二叉树
#### ▍题意

  给定一棵 $n$ 个节点的二叉树，根节点编号为 $1$。每个节点初始为黑色或白色（用 $\texttt{01}$ 串表示）。进行 $q$ 次操作，每次操作选择一个节点，将以该节点为根的子树内所有节点的颜色反转（黑色变白色，白色变黑色）。求 $q$ 次操作后每个节点的颜色。

  数据范围：$n,q \le 10^5$。

----

▍分析
    1. **问题转化**：每次操作是对子树进行颜色翻转，这相当于对子树中所有节点的翻转次数加 $1$。由于颜色翻转具有周期性（翻转两次等于不翻转），我们只关心每个节点被翻转的总次数的奇偶性。
    2. **关键观察**：如果直接模拟每次操作，时间复杂度为 $O(n \times q)$，无法通过。需要优化。
  3. **优化思路**：利用树的性质，记录每个节点被直接操作的次数，然后通过 DFS 将操作信息传递给子节点。具体来说：
     - 用数组 `flag` 记录每个节点被直接操作的次数（模 $2$）
     - 从根节点开始 DFS，如果当前节点有翻转标记，就将标记传递给它的左右子节点
     - 最终每个节点的颜色 = 初始颜色 ⊕ 该节点的翻转标记

---

4. **正确性证明**：

    - 对于任意节点，它的最终翻转次数等于从根节点到该节点路径上所有节点的直接操作次数之和（模 $2$）

    - 在 DFS 过程中，当访问到节点 $x$ 时：
      - 如果 `flag[x] = 1`，说明需要翻转以 $x$ 为根的子树
      - 将标记传递给子节点，相当于记录"从根节点到当前路径上已有奇数次翻转"
      - 这样，每个叶子节点最终得到的标记就是从根节点到该叶子节点路径上所有操作的总效果

  时间复杂度：$O(n)$，其中建树 $O(n)$，DFS 遍历 $O(n)$。

---

▍参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

struct Node {
    int l, r;      // 左右子节点编号
    bool color;    // 节点初始颜色
} tree[N];

bool flag[N];      // 记录每个节点的翻转标记
int n, q;

// DFS遍历树，传递翻转标记
void dfs(int x) {
    int left = tree[x].l, right = tree[x].r;
    
    // 如果当前节点有翻转标记，传递给子节点
    if (flag[x]) {
        if (left) flag[left] ^= 1;   // 翻转左子树
        if (right) flag[right] ^= 1; // 翻转右子树
    }
    
    // 递归处理子树
    if (left) dfs(left);
    if (right) dfs(right);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    cin >> n;
    
    // 建树
    for (int i = 2, parent; i <= n; i++) {
        cin >> parent;
        if (!tree[parent].l) {
            tree[parent].l = i;  // 第一个子节点作为左孩子
        } else {
            tree[parent].r = i;  // 第二个子节点作为右孩子
        }
    }
    
    // 读入初始颜色
    for (int i = 1; i <= n; i++) {
        char ch;
        cin >> ch;
        tree[i].color = (ch == '1');
    }
    
    // 处理操作
    cin >> q;
    for (int i = 0; i < q; i++) {
        int x;
        cin >> x;
        flag[x] ^= 1;  // 标记该节点被操作（异或实现模2计数）
    }
    
    // DFS传递标记
    dfs(1);
    
    // 输出最终颜色：初始颜色 ⊕ 翻转标记
    for (int i = 1; i <= n; i++) {
        cout << (tree[i].color ^ flag[i]);
    }
    
    return 0;
}
```