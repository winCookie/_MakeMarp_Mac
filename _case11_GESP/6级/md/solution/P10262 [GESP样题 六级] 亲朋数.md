### P10262 [GESP样题 六级] 亲朋数
#### ▍题意

  给定一个长度为 $L$ 的数字串 $S$ 和一个正整数 $p$，求 $S$ 的所有连续子串中，对应数值是 $p$ 的倍数的子串个数（允许有前导零）。

  数据范围：$2 \leq p \leq 128$，$1 \leq L \leq 10^6$。

---

#### ▍分析

  1. **问题转化**：需要统计所有连续子串中能被 $p$ 整除的个数。直接枚举所有子串会达到 $O(L^2)$，对于 $L \leq 10^6$ 不可行。

  2. **关键观察**：利用模运算的性质，对于子串 $S[i..j]$ 对应的数值，可以通过前缀和的思想计算。具体地，设 $num(i,j)$ 表示子串 $S[i..j]$ 对应的数值，则：
     $$
     num(i,j) = \sum_{k=i}^{j} (S[k] - '0') \times 10^{j-k}
     $$
     如果 $num(i,j) \equiv 0 \pmod{p}$，则该子串是亲朋数。

     ---
     
     ​	
     
  3. **动态规划思路**：
     
     - 定义 $dp[k]$ 表示以当前数字为结尾的子串中，模 $p$ 余数为 $k$ 的子串个数
     - 遍历字符串，对于每个数字 $d$：
       - 新的余数可以通过旧余数 $j$ 计算：$(j \times 10 + d) \bmod p$
       - 当前数字单独作为一个子串：余数为 $d \bmod p$
     - 每次统计余数为 $0$ 的子串个数
     
  4. **算法正确性**：
     
     - 对于位置 $i$ 的数字 $d$，以它结尾的子串包括：
       - 长度为 $1$ 的子串：$d$
       - 长度 $>1$ 的子串：由前 $i-1$ 个字符的某个后缀加上 $d$ 组成
     - 通过维护模 $p$ 的余数分布，可以高效计算新增的亲朋数

  时间复杂度：$O(L \times p)$，在给定数据范围内可行。

---

#### ▍参考代码

```cpp
const int N = 128;
int p, dp[N], lstdp[N];
long long ans;
string s;

int main() {
    cin >> p >> s;
    for (char ch : s) {
        int d = (ch - '0') % p; // 当前数字模p的余数
        // 保存上一轮的状态
        for (int j = 0; j < p; j++)
            lstdp[j] = dp[j], dp[j] = 0;

        // 状态转移：从上一轮的余数j转移到新的余数
        for (int j = 0; j < p; j++) {
            int new_remainder = (j * 10 + d) % p;
            dp[new_remainder] += lstdp[j];
        }
        // 当前数字单独作为一个子串
        dp[d]++;
        // 统计余数为0的子串个数
        ans += dp[0];
    }

    cout << ans << endl;
    return 0;
}
```