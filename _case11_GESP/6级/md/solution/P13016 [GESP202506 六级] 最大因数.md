### P13016 [GESP202506 六级] 最大因数

#### ▍题意

给定一棵有 $10^9$ 个结点的有根树，结点编号从 $1$ 到 $10^9$，根结点为 $1$。对于编号为 $k$（$2 \leq k \leq 10^9$）的结点，其父结点编号为 $k$ 的因数中除 $k$ 以外最大的因数。现在有 $q$ 组询问，每组询问给出两个结点编号 $x_i, y_i$，要求求出这两个结点在树上的距离（即连接两结点的简单路径的边数）。

数据范围：$1 \leq q \leq 1000$，$1 \leq x_i, y_i \leq 10^9$。

#### ▍分析

根据题意，每个结点（除根结点）的父结点是它除自身外最大的因数。对于偶数，最大因数是 $k/2$；对于奇数，我们需要找到它的最小奇因数（因为最小奇因数对应的因数对中的另一个因数就是最大因数），如果这个最小奇因数是 $k$ 本身（即 $k$ 是质数），那么最大因数就是 $1$。

我们可以通过模拟从 $x$ 和 $y$ 到根结点 $1$ 的路径来求解。两条路径的交集部分（从根结点开始到最近公共祖先的部分）是公共的，我们只需要找到最近公共祖先（LCA），然后距离就是 $x$ 到 LCA 的距离加上 $y$ 到 LCA 的距离。

---

具体步骤：
1. 定义函数 `find(x)` 用于求 $x$ 的父结点。
   - 如果 $x$ 是 $1$，则返回 $0$（表示没有父结点）。
   - 如果 $x$ 是偶数，则父结点为 $x/2$。
   - 如果 $x$ 是奇数，则从 $3$ 开始尝试奇数因子直到 $\sqrt{x}$，如果找到因子 $i$，则返回 $x/i$（因为 $i$ 是最小奇因子，则 $x/i$ 就是最大因子）。如果没有找到，说明 $x$ 是质数，则返回 $1$。

2. 定义函数 `find_path(x)`，返回从 $x$ 到根结点 $1$ 的路径上的所有结点（包括 $x$ 和 $1$）。

---

3. 对于每组询问 $(x, y)$：
   - 分别求出 $x$ 和 $y$ 的路径 `a` 和 `b`。
   - 然后从根结点（即路径的最后一个元素）开始向前比较，找到最后一个相同的结点（即最近公共祖先）。
   - 距离的计算：设 `i` 和 `j` 分别从 `a` 和 `b` 的末尾（根结点）开始向前移动，直到遇到不同的结点。那么 $x$ 到 LCA 的距离为 `i+1`，$y$ 到 LCA 的距离为 `j+1`，但由于我们是从末尾开始比较的，实际计算时距离为 `i + j + 2`。

时间复杂度：每次询问，我们需要分别求出 $x$ 和 $y$ 到根结点的路径。路径的长度最多为 $O(\log x)$ 和 $O(\log y)$，因为每次跳转到父结点，结点编号至少减半。然后比较路径也是 $O(\log n)$。所以总时间复杂度为 $O(q \log n)$，其中 $n$ 是结点编号的最大值（$10^9$）。

---

#### ▍参考代码

```cpp
// 求结点x的父结点
int find(int x) {
    if (x == 1) return 0; // 根结点没有父结点
    if (x % 2 == 0) return x / 2; // 偶数，父结点为x/2
    // 奇数，寻找最小奇因数
    for (int i = 3; i * i <= x; i += 2) {
        if (x % i == 0) {
            return x / i; // 找到最小奇因数i，则父结点为x/i
        }
    }
    return 1; // 是质数，则父结点为1
}

// 求从x到根结点的路径
vector<int> find_path(int x) {
    vector<int> s;
    while (x != 0) { // 当x不为0（根结点的父结点为0）时，继续向上
        s.emplace_back(x);
        x = find(x);
    }
    return s;
}
```

---

```cpp
// 计算x和y之间的距离
int solve(int x, int y) {
    vector<int> a = find_path(x); // x的路径
    vector<int> b = find_path(y); // y的路径
    int i = a.size() - 1, j = b.size() - 1;
    // 从根结点开始（路径的最后一个元素）向前比较，直到遇到第一个不同的结点
    while (i >= 0 && j >= 0 && a[i] == b[j]) {
        i--;
        j--;
    }
    // 距离为 (i+1) + (j+1) = i+j+2
    return i + j + 2;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int x, y;
        cin >> x >> y;
        cout << solve(x, y) << endl;
    }
    return 0;
}
```