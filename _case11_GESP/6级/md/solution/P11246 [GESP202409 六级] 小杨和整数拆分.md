### P11246 [GESP202409 六级] 小杨和整数拆分
#### ▍题意

  将一个正整数 $n$ 拆分成若干个完全平方数的和，求所需完全平方数的最小数量。

  数据范围：$1 \leq n \leq 10^5$。

---

#### ▍分析

  1. **问题转化**：这是一个典型的完全背包问题，需要找到用完全平方数组合成 $n$ 的最小数量。

  2. **关键观察**：
     - 完全平方数可以看作是背包问题中的"物品"
     - 目标值 $n$ 可以看作是背包的"容量"
     - 需要找到组合成 $n$ 所需的最少"物品"数量

---

  3. **动态规划思路**：
     - 定义状态 $dp[i]$ 表示组成数字 $i$ 所需的最少完全平方数个数
     - 预处理所有不超过 $n$ 的完全平方数，存储在数组 $p$ 中
     - 状态转移：对于每个完全平方数 $j$，从 $j$ 到 $n$ 更新：$dp[i] = \min(dp[i], dp[i - j] + 1)$
     - 初始化：$dp[0] = 0$，其他为无穷大

  4. **算法正确性**：
     - 最优子结构：组成 $i$ 的最优解必然由组成 $i - j$ 的最优解加上 $1$ 构成，其中 $j$ 是完全平方数
     - 通过枚举所有可能的完全平方数，并使用完全背包的更新顺序，确保每个完全平方数可以使用多次
     - 预处理完全平方数避免了重复计算

  时间复杂度：$O(n \sqrt{n})$，在 $n \leq 10^5$ 时可行。

---

#### ▍参考代码

```cpp
#define int long long
#define endl "\n"
const int N = 2e5 + 10;
int dp[N], n;
vector<int> p; // 记录 n 以内所有的 完全平方数 i*i
void solve() {
    // 抵达数字 i 的完全平方数方案
    for (int i = 1; i * i <= n; i++)
        p.emplace_back(i * i);
    // 可达性
    dp[0] = 0;
    // 递推（完全背包），求最小值方案
    for (int j : p)                  // 物品
        for (int i = j; i <= n; i++) // 体积
            dp[i] = min(dp[i], dp[i - j] + 1);
}
signed main() {
    memset(dp, 0x3f, sizeof dp); // 求最小值，初始化最大
    cin >> n;
    solve();
    cout << dp[n] << endl;
    return 0;
}
```