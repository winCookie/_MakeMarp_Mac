### P10721 [GESP202406 六级] 计算得分
#### ▍题意

  给定一个长度为 $m$ 的字符串，由小写字母组成。设置一个计分序列 $A = [a_1, a_2, \ldots, a_n]$，如果字符串的一个子串由 $k$ 个 $\texttt{abc}$ 首尾相接组成（$1 \leq k \leq n$），则得分为 $a_k$。字符不能重复使用，求字符串的最大总得分。

  数据范围：$1 \leq n \leq 20$，$1 \leq m \leq 10^5$，$1 \leq a_i \leq 1000$。

---

#### ▍分析

  1. **问题转化**：字符串中可能存在多个连续的 $\texttt{abc}$ 序列段，每个段由 $k$ 个连续的 $\texttt{abc}$ 组成。对于每个段，我们可以将其划分为若干个子段（每个子段由 $i$ 个 $\texttt{abc}$ 组成，$1 \leq i \leq n$），得分分别为 $a_i$。目标是最大化每个段的总得分。

  2. **关键观察**：对于连续 $k$ 个 $\texttt{abc}$ 组成的段，其最大得分可以通过动态规划（完全背包）预处理得到。定义 $dp[j]$ 表示由 $j$ 个 $\texttt{abc}$ 组成的段能获得的最大得分。状态转移方程为：
     $$
     dp[j] = \max(dp[j], dp[j - i] + a_i) \quad \text{对于 } i = 1 \text{ 到 } n
     $$
     这表示将 $j$ 个 $\texttt{abc}$ 划分为一个长度为 $i$ 的子段（得分 $a_i$）和剩余 $j-i$ 个 $\texttt{abc}$ 组成的段（得分 $dp[j-i]$）。

---

  3. **算法步骤**：
     - 预处理 $dp$ 数组：使用完全背包思想，计算每个 $j$ 对应的最大得分。
     - 遍历字符串，统计连续 $\texttt{abc}$ 序列的长度 $k$。每当连续序列中断时，将 $dp[k]$ 加入总得分，并重置 $k$。
     - 注意：字符串遍历时需检查三个字符是否为 $\texttt{abc}$，以避免重复计算。

  4. **正确性证明**：预处理 $dp$ 数组确保了对于任意 $k$，都能得到划分后的最大得分。字符串遍历正确识别了所有连续的 $\texttt{abc}$ 序列段，且字符不重复使用。

  时间复杂度：预处理 $dp$ 为 $O(n \cdot M)$（$M$ 为最大连续 $\texttt{abc}$ 数量，取 $20005$），遍历字符串为 $O(m)$，总时间复杂度为 $O(n \cdot M + m)$。

---

#### ▍参考代码

```cpp
const int N = 25;      // 计分序列最大长度
const int M = 20005;   // 最大连续abc数量估计值
int cost[N];           // 存储计分序列a_i
int dp[M];             // dp[j]：j个连续abc的最大得分
int n, m;
string s;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> cost[i];
        // 完全背包预处理：对于每个长度i，更新所有j>=i的dp值
        for (int j = i; j < M; j++) 
            dp[j] = max(dp[j], dp[j - i] + cost[i]);
    }
    
    cin >> m;
    cin >> s;
    s += "   ";  // 添加三个空格，防止越界
    int ans = 0; // 总得分
    int k = 0;   // 当前连续abc数量
    int i = 0;   // 字符串索引
```

---

```cpp
    while (i < m) {
        // 检查当前位置开始的三个字符是否为"abc"
        if (s[i] == 'a' && s[i+1] == 'b' && s[i+2] == 'c') {
            k++;       // 增加连续计数
            i += 3;    // 跳过三个字符
        } else {
            ans += dp[k]; // 当前连续段结束，加入得分
            k = 0;        // 重置计数
            i++;          // 移动到下一个字符
        }
    }
    // 处理末尾可能剩余的连续段
    ans += dp[k];
    
    cout << ans << endl;
    return 0;
}
```