### P11375 [GESP202412 六级] 树上游走
#### ▍题意

  给定一棵无限节点的二叉树，根节点编号为 $1$，节点 $i$ 的左儿子为 $2i$，右儿子为 $2i+1$。从节点 $s$ 开始，按照给定的移动序列（U: 向上移动，L: 向左儿子移动，R: 向右儿子移动）移动 $n$ 次，求最终所在的节点编号。

  数据范围：$1 \leq n \leq 10^6$，$1 \leq s \leq 10^{12}$，保证最终节点编号不超过 $10^{12}$。

#### ▍分析

  1. **问题转化**：在无限二叉树中按照给定序列移动，需要高效处理移动操作，避免直接模拟导致数值溢出或效率低下。

  2. **关键观察**：
     - 二叉树节点编号有规律：节点 $i$ 的父节点为 $\lfloor i/2 \rfloor$，左儿子为 $2i$，右儿子为 $2i+1$。
     - 当节点编号接近 $10^{12}$ 时，继续向下移动可能导致数值溢出，但题目保证最终节点编号不超过 $10^{12}$，因此可以安全处理。

---

  3. **算法思路**：
     - 使用变量 $s$ 记录当前节点编号，$tag$ 记录"虚拟"的向下移动次数。
     - 遍历移动序列：
       - 遇到 'U'（向上移动）：如果有 $tag$ 则抵消一次，否则如果当前不是根节点则移动到父节点。
       - 遇到 'L'（向左移动）：如果 $2s > 10^{12}$ 则增加 $tag$，否则移动到左儿子。
       - 遇到 'R'（向右移动）：如果 $2s+1 > 10^{12}$ 则增加 $tag$，否则移动到右儿子。
     - 最终输出 $s$。

---

  4. **正确性证明**：
     - $tag$ 的作用是记录那些会导致节点编号超过 $10^{12}$ 的向下移动。由于题目保证最终节点编号不超过 $10^{12}$，这些"虚拟"的向下移动最终会被向上的移动抵消。
     - 当遇到向上移动时，优先抵消 $tag$，因为实际的向上移动会回到一个编号更小的节点，而 $tag$ 代表的虚拟向下移动也需要相应的向上移动来抵消。
     - 这种方法确保了在移动过程中不会产生超过 $10^{12}$ 的节点编号，同时正确记录了移动的净效果。

  5. **时间复杂度**：$O(n)$，只需遍历一次移动序列。

---

▍参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const long long INF = 1e12; // 最大节点编号限制

int main() {
    int n;
    long long s;
    cin >> n >> s;
    
    int tag = 0; // 记录虚拟向下移动次数
    
    for (int i = 0; i < n; i++) {
        char ch;
        cin >> ch;
        
        if (ch == 'U') {
            // 向上移动
            if (tag > 0) {
                tag--; // 抵消一次虚拟向下移动
            } else if (s != 1) {
                s /= 2; // 移动到父节点
            }
        } else if (ch == 'L') {
            // 向左儿子移动
            if (s * 2 > INF) {
                tag++; // 虚拟向下移动
            } else {
                s = s * 2; // 实际移动到左儿子
            }
        } else if (ch == 'R') {
            // 向右儿子移动
            if (s * 2 + 1 > INF) {
                tag++; // 虚拟向下移动
            } else {
                s = s * 2 + 1; // 实际移动到右儿子
            }
        }
    }
    
    cout << s << endl;
    return 0;
}
```