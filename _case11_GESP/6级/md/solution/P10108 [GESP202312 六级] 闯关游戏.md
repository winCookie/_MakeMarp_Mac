### P10108 [GESP202312 六级] 闯关游戏
#### ▍题意

  游戏有 $N$ 关，每关有 $M$ 个通道，第 $i$ 个通道可以前进 $a_i$ 关。离开第 $s$ 关时获得 $b_s$ 分。从第 $0$ 关开始，求通关时能获得的最大总分。

  数据范围：$1 \le N \le 10^4$，$1 \le M \le 100$，$1 \le a_i \le N$，$|b_i| \le 10^5$。

#### ▍分析

  1. **问题转化**：这是一个动态规划问题，需要找到从第 $0$ 关到达第 $N$ 关或之后关卡的最大得分路径。

  2. **关键观察**：
     - 定义状态 $f[i]$ 表示到达第 $i$ 关时能获得的最大分数
     - 状态转移：对于每个关卡 $i$，考虑所有可能的通道 $j$，如果 $i \ge a_j$，则可以从第 $i-a_j$ 关通过通道 $j$ 到达第 $i$ 关
     - 转移方程：$f[i] = \max_{j} \{ f[i-a_j] + b[i-a_j] \}$


---

  3. **算法步骤**：
     - 初始化 $f[0] = 0$，其他为负无穷（因为可能有负分关卡）
     - 对于 $i$ 从 $1$ 到 $N + \max(a)$：
       - 对于每个通道 $j$：
         - 如果 $i \ge a_j$，则更新 $f[i] = \max(f[i], f[i-a_j] + b[i-a_j])$
     - 答案取 $f[N]$ 到 $f[N+\max(a)]$ 中的最大值（因为可能超过 $N$ 关通关）

  4. **正确性证明**：
     - 最优子结构：到达第 $i$ 关的最优解必然由到达某个 $i-a_j$ 关的最优解加上 $b[i-a_j]$ 构成
     - 无后效性：当前状态只依赖于之前的状态
     - 通过遍历所有可能的转移，确保找到全局最优解

  时间复杂度：$O((N + \max(a)) \times M)$，在给定数据范围内可行。

---

▍参考代码
```cpp
const int N = 20010; // 最大可能到达 N + max(a)
const int INF = 0x3f3f3f3f;
int f[N], a[110], b[10010];
int n, m, max_a;

int main() {
    // 初始化
    memset(f, -0x3f, sizeof(f));
    f[0] = 0;

    cin >> n >> m;
    // 读入通道信息
    for (int i = 0; i < m; i++)
        cin >> a[i], max_a = max(max_a, a[i]); // 记录最大步长

    // 读入关卡得分
    for (int i = 0; i < n; i++)
        cin >> b[i];

    // 动态规划
    for (int i = 1; i <= n + max_a; i++)
        for (int j = 0; j < m; j++)
            if (i - a[j] >= 0)
                // 从第 i-a[j] 关通过通道 j 到达第 i 关
                // 离开第 i-a[j] 关时获得 b[i-a[j]] 分
                f[i] = max(f[i], f[i - a[j]] + b[i - a[j]]);

    // 在通关状态中找最大值
    int ans = -INF;
    for (int i = n; i <= n + max_a; i++)
        ans = max(ans, f[i]);

    cout << ans << endl;
    return 0;
}
```