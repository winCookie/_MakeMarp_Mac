# P5657 [CSP-S 2019] 格雷码

## 题目分析

这道题要求我们根据给定的编号 $k$，找出对应的 $n$ 位格雷码。格雷码的特点是相邻的两个二进制串只有一位不同，且第一个和最后一个也相邻。

## 思路

图片中的代码使用了格雷码的一个**数学性质**：

**$n$ 位格雷码的第 $k$ 个码字可以通过公式 $k \oplus \lfloor k/2 \rfloor$ 计算得到**

其中 $\oplus$ 表示按位异或运算。

### 为什么这个公式有效？

让我们通过例子来理解：

对于 3 位格雷码（$n=3$）：
- $k=0$: $0 \oplus 0 = 0$ → 000
- $k=1$: $1 \oplus 0 = 1$ → 001  
- $k=2$: $2 \oplus 1 = 3$ → 011
- $k=3$: $3 \oplus 1 = 2$ → 010
- $k=4$: $4 \oplus 2 = 6$ → 110
- $k=5$: $5 \oplus 2 = 7$ → 111
- $k=6$: $6 \oplus 3 = 5$ → 101
- $k=7$: $7 \oplus 3 = 4$ → 100

这与题目描述的格雷码序列完全一致。

## 代码解析

```cpp
int n;
ull k;
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    cin >> n >> k;
    // 公式法构造 k ^= k-1
    k ^= k >> 1;
    while (n)
        cout << ((k >> (n - 1)) & 1), n--;
    return 0;
}
```

### 为什么使用 `unsigned long long`？

- 题目数据范围：$1 \leq n \leq 64$, $0 \leq k < 2^n$
- 当 $n=64$ 时，$k$ 最大为 $2^{64}-1$，这超出了普通 `long long` 的范围
- `unsigned long long` 可以表示 $0$ 到 $2^{64}-1$ 的整数
