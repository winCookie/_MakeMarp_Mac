### P11247 [GESP202409 六级] 算法学习
▍题意
  小杨需要学习 $m$ 种算法，有 $n$ 道题目，每道题目属于一个知识点 $a_i$ 并提升掌握程度 $b_i$。目标是对每种算法的掌握程度至少达到 $k$，且不能连续学习两道相同知识点的题目。求最少需要学习的题目数量，如果无法满足条件则输出 $-1$。

  数据范围：$1 \leq m, n, b_i, k \leq 10^5$，$1 \leq a_i \leq m$。

---

▍分析
  1. **问题转化**：将题目按知识点分组，对于每个知识点，需要选择若干题目使其总掌握程度至少为 $k$。同时，在学习顺序中，不能连续学习相同知识点的题目。

  2. **关键步骤**：
     - **分组与贪心**：对于每个知识点，将其题目按掌握程度降序排序，贪心选择题目直到总掌握程度 $\geq k$，记录每个知识点所需的最少题目数 $\text{cnt}[i]$。
     - **总题目数**：计算所有知识点所需题目数的总和 $\text{ans} = \sum \text{cnt}[i]$。
     - **检查可行性**：如果任何知识点无法达到 $k$，输出 $-1$。

---

  3. **学习顺序的约束**：不能连续学习相同知识点的题目。这要求在学习顺序中，对于每个知识点，其题目不能被连续安排。

     设 $\text{max\_cnt}$ 为所有知识点中所需题目数的最大值。

     为了满足间隔条件，其他知识点的题目数必须至少为 $\text{max\_cnt} - 1$。

     这是因为，如果某个知识点需要 $\text{max\_cnt}$ 个题目，那么在安排顺序时，每两个该知识点的题目之间至少需要一个其他知识点的题目作为间隔。

     因此，总的其他知识点题目数应不少于 $\text{max\_cnt} - 1$。

---

  4. **优化条件与组合数学原理**：

   - 如果 $\text{ans} - \text{max\_cnt} \geq \text{max\_cnt} - 1$，则总的其他知识点题目数足够提供间隔，可以直接使用 $\text{ans}$ 个题目。

   - 否则，考虑其他知识点中未使用的题目（即已经达到 $k$ 但还有剩余题目的部分）。设 $\text{need}$ 为其他知识点未使用的题目总数。如果 $\text{ans} - \text{max\_cnt} + \text{need} \geq \text{max\_cnt} - 1$，则可以通过额外选择一些题目来填充间隔，使总题目数达到 $2 \times \text{max\_cnt} - 1$。

---

   - **组合数学基础**：这里的优化基于鸽巢原理和序列安排问题。

       对于一个需要 $x$ 个题目的知识点，在学习序列中，这 $x$ 个题目最多可以出现 $x$ 次，但每两个之间必须有一个其他题目的间隔。

       因此，整个序列中其他题目的数量至少为 $x-1$。

       如果其他题目的数量不足，我们可以从其他知识点中抽取未使用的题目来增加间隔，但这会增加总题目数。

       总题目数的最小值取决于最大知识点的题目数和其他知识点的题目可用性，最小可能值为 $2x - 1$（当其他题目刚好满足间隔时）。

---

  5. **示例说明**：
     考虑以下示例：
     ```
     知识点1：题目 [9, 1]  → 需要2题（9+1=10）
     知识点2：题目 [10]    → 需要1题
     知识点3：题目 [10, 1] → 需要1题
     ```
     总题目数 $\text{ans} = 2 + 1 + 1 = 4$，最大题目数 $\text{max\_cnt} = 2$。
     检查间隔条件：$\text{ans} - \text{max\_cnt} = 2 \geq \text{max\_cnt} - 1 = 1$，满足条件，因此可以直接输出4。

     ```
     ｜B｜C｜
      A、A
     ```

     可以这么理解，把 B、C 看作题目 2、3，那么最多的题目 1 设为 A。

     ```
     ABAC
     ABCA
     BACA
     ```

     以上都是合法的放入方案，除了最多题目数量以外的题目数量 ans，如果能够插入最多题目数量的中间空隙，说明方案可以正常摆放。

     ---

     

     一个知识点1需要很多题目，而其他知识点题目很少的情况。例如：
     ```
     知识点1：题目 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  → 需要10题（10个1）
     知识点2：题目 [10]                             → 需要1题
     知识点3：题目 [10]                             → 需要1题
     ```
     总题目数 $\text{ans} = 10 + 1 + 1 = 12$，最大题目数 $\text{max\_cnt} = 10$。
     检查间隔条件：$\text{ans} - \text{max\_cnt} = 2 < 10 - 1 = 9$，不满足。
     然后计算剩余题目：知识点2和3都没有剩余题目（因为每个知识点只有1题，已经全部使用）。
     所以 $\text{ans} - \text{max\_cnt} + \text{need} = 2 + 0 = 2 < 9$，无法满足，输出-1。

     

  6. **时间复杂度**：主要耗时在于对每个知识点的题目排序。每个知识点最多有 $n$ 个题目，但总题目数为 $n$，因此排序的总时间复杂度为 $O(n \log n)$，在数据范围内可行。

---

▍参考代码
```cpp
const int N = 100010;
int n, m, k;
vector<int> p[N]; // p[i]存储知识点i的所有题目掌握程度
int cnt[N];       // cnt[i]表示知识点i所需的最少题目数

int main() {
    cin >> m >> n >> k;
    // 读入每道题的知识点
    vector<int> a(n);
    for (int i = 0; i < n; i++) 
        cin >> a[i];
    
    // 读入每道题的掌握程度并分组
    for (int i = 0,b; i < n; i++) 
        cin >> b; p[a[i]].push_back(b);

    int ans = 0,max_cnt = 0, max_idx = 0;     // 总题目数 / 最大知识点题目数 / 对应知识点编号

    // 处理每个知识点
    for (int i = 1; i <= m; i++) {
        // 如果该知识点没有题目，无法达到k
        if (p[i].empty()) cout << -1 << endl, exit(0);

        // 按掌握程度降序排序
        sort(p[i].begin(), p[i].end(), greater<int>());
        int sum = 0, cnt[i] = 0;
        // 贪心选择题目直到达到k
        for (int val : p[i]) {
            sum += val, cnt[i]++;
            if (sum >= k)
                break;
        }
		// 无法达到k
        if (sum < k) 
            cout << -1 << endl, exit(0);

        ans += cnt[i];
        // 更新最大题目数知识点
        if (cnt[i] > max_cnt) 
            max_cnt = cnt[i], max_idx = i;
    }

    // 检查是否满足间隔条件
    if (ans - max_cnt >= max_cnt - 1) 
        cout << ans << endl;
    else {
        // 计算其他知识点的剩余题目数
        int need = 0;
        for (int i = 1; i <= m; i++) 
          if (i != max_idx) 
            need += p[i].size() - cnt[i];
          // 检查是否可以通过额外选题满足间隔
          if (ans - max_cnt + need >= max_cnt - 1) 
              // 总题目数需要达到2*max_cnt-1
              cout << 2 * max_cnt - 1 << endl;
          else 
              cout << -1 << endl;
    }

    return 0;
}
```