### P14076 [GESP202509 六级] 货物运输

#### ▍题意  

A 国有 $n$ 座城市，通过 $n-1$ 条双向道路连接形成一棵树。首都为 $1$ 号城市。需要从首都出发，经过所有城市（允许重复经过），最后无需返回首都。求经过的道路长度总和的最小值。  
数据范围：$1 \le n \le 10^5$，$1 \le l_i \le 10^9$。

---

#### ▍分析  

问题本质是在树结构中寻找从根节点出发遍历所有节点的最短路径。由于树是无环连通图，从根节点出发访问所有节点并返回根节点的总路径长度为所有边权之和的两倍，即 $2 \sum l_i$（因为每条边需要往返各一次）。但题目允许最后不返回根节点，因此可以省去从最远叶子节点返回根节点的路径。设从根节点到最远叶子节点的路径长度为 $d_{\text{max}}$，则最小总路径长度为 $2 \sum l_i - d_{\text{max}}$。  

---

- **推导过程**：  
  1. 从根节点开始深度优先遍历（DFS），计算每个节点到其子树中最远叶子节点的路径长度。  
  2. 在 DFS 过程中，对于节点 $u$，遍历其子节点 $v$，计算从 $v$ 出发的最长路径 $v_{\text{path}}$，则经过 $u$ 的路径长度为 $v_{\text{path}} + w(u,v)$。取所有子节点中的最大值更新 $u$ 的最长路径。  
  3. 全局记录从根节点到最远叶子节点的路径长度 $d_{\text{max}}$。  
    最终答案为 $2 \sum l_i - d_{\text{max}}$。  
    时间复杂度：DFS 遍历整个树，每个节点访问一次，时间复杂度为 $O(n)$。

---

▍参考代码  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"
typedef long long ll;
const int N = 1e5 + 10;

struct edge {
    int v, w; // v: 相邻节点, w: 边权
};
vector<edge> e[N]; // 邻接表存储树
ll total_sum;      // 所有边权之和
ll max_path;       // 从根节点到最远叶子节点的路径长度

// DFS 计算从当前节点 u 到子树中最远叶子节点的路径长度
ll dfs(int u, int fa) {
    ll u_path = 0; // 记录从 u 出发的最长路径
    for (auto eg : e[u]) {
        int v = eg.v, w = eg.w;
        if (v == fa) continue; // 避免回溯父节点
        ll v_path = dfs(v, u); // 递归计算子节点 v 的最长路径
        u_path = max(u_path, v_path + w); // 更新 u 的最长路径
    }
    max_path = max(max_path, u_path); // 更新全局最长路径
    return u_path;
}

int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    int n;
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        e[u].push_back({v, w});
        e[v].push_back({u, w});
        total_sum += w; // 累加边权
    }
    dfs(1, 0); // 从根节点 1 开始 DFS，父节点初始为 0
    cout << total_sum * 2 - max_path << endl;
    return 0;
}
```