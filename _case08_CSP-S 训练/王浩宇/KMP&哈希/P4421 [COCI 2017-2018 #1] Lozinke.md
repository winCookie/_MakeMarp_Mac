### P4421 [COCI 2017/2018 #1] Lozinke

▍题意
给定一个字符串 $U$，它是由字符串 $S$ 经过以下操作得到的：先将 $S$ 复制两份得到 $T$（即 $T = S + S$），然后在 $T$ 的任意位置（包括首尾）插入一个字符得到 $U$。要求根据 $U$ 还原出原始的字符串 $S$。如果存在多个可能的 $S$，则输出 "NOT UNIQUE"；如果无法还原，则输出 "NOT POSSIBLE"。

数据范围：字符串 $U$ 的长度 $n$ 满足 $1 \leq n \leq 2 \times 10^6$，且 $n$ 为奇数（因为插入一个字符后长度为奇数）。

▍分析
由于 $U$ 是由 $S$ 复制两次后插入一个字符得到的，因此 $U$ 的长度 $n$ 必为奇数。如果 $n$ 为偶数，直接输出 "NOT POSSIBLE"。对于奇数 $n$，设 $mid = \lfloor n/2 \rfloor$，则 $S$ 的长度应为 $mid$。算法核心是枚举插入字符的位置，并利用字符串哈希快速比较删除该字符后剩余部分是否能分成两个相等的子串（即 $S$）。

具体步骤：
1. 预处理字符串 $U$ 的哈希值，使用基数 $base = 22783$ 和自然溢出（unsigned long long）作为模数。
2. 计算前缀哈希数组 $h[i]$ 和基数幂数组 $pre[i]$，使得可以在 $O(1)$ 时间内计算任意子串的哈希值。
3. 枚举插入字符的位置 $k$：
   - 如果 $k \leq mid$，则删除 $U[k]$ 后，前 $mid$ 个字符（跳过 $k$）应与后 $mid$ 个字符匹配。
   - 如果 $k > mid$，则删除 $U[k]$ 后，前 $mid$ 个字符应与后 $mid$ 个字符（跳过 $k$）匹配。
4. 使用哈希值比较匹配情况，记录所有可行的 $S$。如果找到多个不同的 $S$，输出 "NOT UNIQUE"；如果只有一个，输出该 $S$；如果没有，输出 "NOT POSSIBLE"。

时间复杂度：$O(n)$，因为预处理哈希值需要 $O(n)$，枚举每个位置并检查需要 $O(1)$ 时间。

▍参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll unsigned long long
#define endl "\n"
const int N = 20005;
unordered_map<ll, int> _hash, _hash2; // 整串的hash，串是否已出现
ll vis[N];                            // 记录子串 hash，用于避免重复计算贡献
string s[N];
int n;
ll get(string t, int l, int r) {
    ll _hashcode = 1;
    for (int i = l; i <= r; i++)
        _hashcode = _hashcode * 26 + (t[i] - 'a') + 1;
    return _hashcode;
}
void solve() {
    for (int i = 1; i <= n; i++)
        _hash[get(s[i], 0, s[i].size() - 1)]++;
}
ll check(string t) {
    ll ans = -1; /* 0～0 是空串肯定存在，则预-1 */
    int len = t.size(), cnt = 0;
    /* 暴力枚举子串 */
    for (int i = 0; i < len; i++)
        for (int j = i; j < len; j++) {
            /* 子串存在 && 子串没有计算过贡献 */
            ll _subhashcode = get(t, i, j);
            if (_hash[_subhashcode] && !_hash2[_subhashcode]) {
                ans += _hash[_subhashcode];
                _hash2[_subhashcode] = 1, vis[++cnt] = _subhashcode;
            }
        }
    /* 还原占位 */
    for (int i = 1; i <= cnt; i++)
        _hash2[vis[i]] = 0;
    return ans;
}
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> s[i];
    solve();
    ll ans = 0;
    for (int i = 1; i <= n; i++)
        ans += check(s[i]);
    cout << ans << endl;
    return 0;
}
```