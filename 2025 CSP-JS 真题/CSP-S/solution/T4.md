### P14364 [CSP-S 2025] 员工招聘 / employ（民间数据）

#### ▍题意

  有 $n$ 个人应聘，公司希望录用至少 $m$ 人。面试持续 $n$ 天，每天面试一个人，顺序由排列 $p$ 决定。每天面试题难度 $s_i \in \{0,1\}$：$s_i = 0$ 表示题难，无人能做出，面试者被拒绝；$s_i = 1$ 表示题易，所有人都能做出，面试者被录用。但每个人有耐心上限 $c_i$，如果在他面试之前被拒绝或放弃的人数不少于 $c_i$，则他会放弃面试。求有多少种排列 $p$ 使得最终录用人数至少为 $m$。
  数据范围：$1 \leq m \leq n \leq 500$，$0 \leq c_i \leq n$。

#### ▍分析

  观察数据范围，允许 $O(n^3)$ 算法，考虑动态规划。设状态 $dp_{i,j,k}$ 表示已经过了 $i$ 天，有 $j$ 个人被拒绝或放弃，且前 $i$ 天中有 $k$ 个人满足 $c_k \leq j$ 时的方案数（不考虑 $c_k > j$ 的人之间的差别）。定义 $cnt_x$ 为满足 $c_i = x$ 的人数，$pre_x$ 为 $cnt_x$ 的前缀和。

  转移时根据第 $i+1$ 天的难度 $s_{i+1}$ 分类：
  - 若 $s_{i+1} = 0$：则当天面试者会被拒绝，因此 $j$ 增加 $1$。枚举可能的 $k'$（满足 $k \leq k' \leq k + cnt_{j+1}$），计算新状态。转移系数涉及组合数和排列数，具体为：
    $$
    \text{new} = dp_{i,j,k} \times \binom{i - k}{k' - k} \times \binom{cnt_{j+1}}{k' - k} \times (k' - k)!
    $$
    然后根据当天面试者的 $c$ 值是否 $\leq j+1$ 进一步转移：
    - 若 $\leq j+1$，则 $dp_{i+1,j+1,k'+1} \leftarrow \text{new} \times (pre_{j+1} - k')$。
    - 若 $> j+1$，则 $dp_{i+1,j+1,k'} \leftarrow \text{new}$。
  - 若 $s_{i+1} = 1$：当天面试者可能被录用或放弃。先处理 $c > j$ 的情况，直接转移到 $dp_{i+1,j,k}$；对于 $c \leq j$ 的情况，类似 $s_{i+1}=0$ 处理，但仅转移到 $dp_{i+1,j+1,k'+1}$，系数为 $\text{new} \times (pre_j - k)$。

  最终答案需要统计所有 $j \leq n - m$ 的状态，并乘上 $c_k > j$ 的人的排列方案数，即：
$$
  \text{ans} = \sum_{j=0}^{n-m} dp_{j, pre_j} \times (n - pre_j)!
$$
  时间复杂度：$O(n^3)$，空间优化后使用二维数组实现。

#### ▍参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353, N = 505;
long long f[N], g[N], inv[N];       // f:阶乘，g:阶乘逆元，inv:逆元
int n, m, cnt[N], pre[N], dp[N][N]; // cnt[c]: 耐心上限为 c 的人数，pre: cnt 的前缀和
char s[N];                          // 每天的面试题难度

int main() {
    scanf("%d %d", &n, &m);
    // 预处理阶乘、逆元和阶乘逆元
    f[0] = f[1] = g[0] = g[1] = inv[1] = 1;
    for (int i = 2; i <= n; i++) {
        f[i] = f[i - 1] * i % mod;                     // 计算 i 的阶乘
        inv[i] = inv[mod % i] * (mod - mod / i) % mod; // 线性求逆元
        g[i] = g[i - 1] * inv[i] % mod;                // 计算阶乘逆元
    }

    scanf("%s", s + 1);
    for (int i = 1, c; i <= n; i++) {
        scanf("%d", &c);
        cnt[c]++; // 统计每个耐心上限的人数
    }

    // 计算前缀和：pre[i] = 耐心上限<=i的总人数
    pre[0] = cnt[0];
    for (int i = 1; i <= n; i++)
        pre[i] = pre[i - 1] + cnt[i];

    // dp初始化：0 天，0 人被拒，0 个c<=0的人
    dp[0][0] = 1;

    // 动态规划：按天数转移
    for (int i = 0; i < n; i++) // 已进行 i 天
    {
        for (int j = i; j >= 0; j--) // 已被拒绝或放弃的人数（倒序）
        {
            for (int k = pre[j]; k >= 0; k--) // 前 i 天中c<=j的人数（倒序）
            {
                int now = dp[j][k]; // 当前状态方案数
                dp[j][k] = 0;       // 清空当前状态（滚动数组）

                if (s[i + 1] == '0') // 第 i+1 天题目难，必被拒
                {
                    // 枚举可能的 k2：新状态中 c<=j+1 的人数
                    for (int k2 = max(k, i - (n - pre[j + 1]));
                         k2 <= k + cnt[j + 1] && k2 <= i; k2++) {
                        const int tot = i - k;      // c>j 的人数
                        const int ths = k2 - k;     // 新增的 c=j+1 的人数
                        const int num = cnt[j + 1]; // 耐心上限 =j+1 的总人数

                        // 计算转移系数：组合数 × 排列数
                        const long long x = f[tot] * g[ths] % mod *
                                            g[tot - ths] % mod * f[num] % mod *
                                            g[num - ths] % mod;

                        // 第 i+1 天的人 c>j+1：转移到 dp[j+1][k2]
                        if (j + 1 != n && pre[j + 1] - k2 != n - i)
                            dp[j + 1][k2] = (dp[j + 1][k2] + x * now) % mod;

                        // 第 i+1 天的人 c<=j+1：转移到 dp[j+1][k2+1]
                        dp[j + 1][k2 + 1] =
                            (dp[j + 1][k2 + 1] +
                             x * now % mod * (pre[j + 1] - k2)) %
                            mod;
                    }
                } else // 第 i+1 天题目简单，可能被录用
                {
                    // 枚举可能的 k2：新状态中 c<=j+1 的人数
                    for (int k2 = max(k, i - (n - pre[j + 1]));
                         k2 <= k + cnt[j + 1] && k2 <= i; k2++) {
                        const int tot = i - k;      // c>j 的人数
                        const int ths = k2 - k;     // 新增的 c=j+1 的人数
                        const int num = cnt[j + 1]; // 耐心上限 =j+1 的总人数

                        // 计算转移系数
                        const long long x = f[tot] * g[ths] % mod *
                                            g[tot - ths] % mod * f[num] % mod *
                                            g[num - ths] % mod;

                        // 第 i+1 天的人 c<=j：被录用，但耐心不足会放弃，转移到 dp[j+1][k2+1]
                        dp[j + 1][k2 + 1] =
                            (dp[j + 1][k2 + 1] + x * now % mod * (pre[j] - k)) %
                            mod;
                    }

                    // 第 i+1 天的人 c>j：被录用且不会放弃，直接转移到 dp[j][k]
                    if (pre[j] - k != n - i)
                        dp[j][k] = now;
                }
            }
        }
    }

    // 统计答案：录用人数>=m，即拒绝人数<=n-m
    int ans = 0;
    for (int j = 0; j <= n - m; j++) {
        const int k = pre[j]; // 所有c<=j的人数
        // 乘以剩余人的排列数（c>j的人可以任意排列）
        ans = (ans + dp[j][k] * f[n - k]) % mod;
    }
    printf("%d", ans);
    return 0;
}
```