# P14362 [CSP-S 2025] 道路修复 / road 题解

## 题意

有 $n$ 座城市和 $m$ 条双向道路，所有道路都被地震破坏。还有 $k$ 个乡镇可以选择进行城市化改造。

**目标**：以最小费用让原有的 $n$ 座城市相互连通。

**可选方案**：
- 修复原有道路，费用为 $w_i$
- 选择乡镇进行城市化改造（费用 $c_j$），然后建造乡镇到城市的道路（费用 $a_{j,i}$）

**约束条件**：
- $1 \leq n \leq 10^4$，$1 \leq m \leq 10^6$，$0 \leq k \leq 10$
- 可以选择任意多个乡镇（包括 $0$ 个）

## 分析

## 部分分策略

### 测试点 1-4 ($k = 0$)
直接求原图的最小生成树即可，无需考虑乡镇。

### 测试点 5-6, 9-10, 13-14, 17-18 (特殊性质 A)
性质 A：$c_j = 0$ 且存在 $a_{j,i} = 0$
- 乡镇改造免费且至少有一条免费道路
- 可以优先考虑这些乡镇，因为可能零成本获得连接

---

### 核心思想：状态压缩 + 最小生成树

由于 $k \leq 10$，我们可以枚举所有乡镇的选择方案（共 $2^k$ 种状态），对每种状态构建新图并求最小生成树。

### 具体步骤

1. **预处理原图的最小生成树**
    - 使用 Kruskal 算法求出原图的最小生成树
    - 保留这 $n-1$ 条边作为候选边集

2. **枚举乡镇选择状态**
    - 对于每个状态 $state \in [0, 2^k)$
    - 计算选择乡镇的改造费用总和
    - 构建包含城市和所选乡镇的图

3. **构建新图并求最小生成树**
    - 节点：$n$ 个城市 + 所选乡镇
    - 边：原图最小生成树边 + 所选乡镇到所有城市的边
    - 使用 Kruskal 算法求新图的最小生成树

4. **更新答案**
    - 总费用 = 乡镇改造费用 + 最小生成树边权和
    - 取所有状态中的最小值

### 时间复杂度分析

- 状态数：$O(2^k)$，$k \leq 10$ 时约为 $1024$
- 每状态边数：$O(n + n \cdot k) \approx 10^4 + 10^5$
- 排序复杂度：$O((n + nk)\log(n + nk))$
- 总复杂度：$O(2^k \cdot (n + nk)\log(n + nk))$，在数据范围内可接受

## 参考代码

```cpp
#define ll long long
#define endl "\n"

const int N = 1e4 + 15, M = 2e6;
struct edge {
    int u, v, w;
    bool operator<(const edge &b) const { return w < b.w; }
} e[M];
int n, m, k, fa[N], tot, cost[15], vis[15];
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }

int main() {
    cin >> n >> m >> k;

    // 初始化并查集
    for (int i = 1; i <= n; i++) fa[i] = i;

    // 读入原图边
    for (int u, v, w, i = 1; i <= m; i++) {
        cin >> u >> v >> w;
        e[i] = (edge){u, v, w};
    }

    // 步骤1：求原图最小生成树
    sort(e + 1, e + 1 + m);
    tot = 0;
    for (int i = 1; i <= m; i++) {
        int fu = find(e[i].u), fv = find(e[i].v);
        if (fu != fv) {
            fa[fu] = fv;
            e[++tot] = e[i]; // 保留最小生成树边
            if (tot == n - 1)
                break;
        }
    }

    // 读入乡镇信息
    // 乡镇编号为 n+1 到 n+k
    for (int i = 1; i <= k; i++) {
        cin >> cost[i]; // 乡镇改造费用
        for (int j = 1, w; j <= n; j++) {
            cin >> w;
            e[++tot] = {j, n + i, w}; // 乡镇到城市的边
        }
    }

    // 当前边集：原图最小联通的边(n-1) + 所有村庄与城市的连边(n*k)
    // krusual 贪心边集排序
    sort(e + 1, e + 1 + tot);

    ll res = 1e18; // 初始化最小答案为极大值

    // 步骤2：枚举所有乡镇选择方案
    for (int state = 0; state < (1 << k); state++) {
        int num = 0;         // 选择的乡镇数量
        ll current_cost = 0; // 当前状态总费用

        // 计算乡镇改造费用
        for (int i = 1; i <= k; i++) {
            if ((state >> (i - 1)) & 1) {
                num++;
                current_cost += cost[i];
                vis[i] = 1; // 标记该乡镇被选择
            } else {
                vis[i] = 0;
            }
        }

        // 初始化并查集（城市 + 所选乡镇）
        for (int i = 1; i <= n + k; i++)
            fa[i] = i;

        int need = num + n - 1; // 联通 n 个城市所需边数
        int edges_used = 0;     // 已使用的边数

        // 步骤3：构建最小生成树
        for (int i = 1; i <= tot && edges_used < need; i++) {
            int u = e[i].u, v = e[i].v;

            // 如果边连接了未选择的乡镇，跳过
            if (v > n && !vis[v - n])
                continue;

            int fu = find(u), fv = find(v);
            if (fu != fv) {
                fa[fu] = fv, current_cost += e[i].w;
                edges_used++;
            }
        }
        // 步骤4：更新答案
        if (edges_used == need) 
            res = min(res, current_cost);
    }
    cout << res << endl;
    return 0;
}
```

## 小结

1. **状态压缩枚举** $k \leq 10$ 的特点，枚举所有 $2^k$ 种乡镇选择方案
2. **图构建技巧**：将乡镇视为特殊节点（编号 $n+1$ 到 $n+k$），统一处理
4. **边集预处理**：先求原图最小生成树，减少后续计算量

